name: üî¢ Incr√©menter automatiquement la version

permissions:
  contents: write

on:
  push:
    branches: [main]
    paths-ignore:
      - 'version.txt'
      - 'CHANGELOG.md'
      - '.app_data/**'
      - 'README.md'
      - '.github/**'

jobs:
  auto-version:
    name: D√©tecter et incr√©menter la version
    runs-on: ubuntu-latest
    
    steps:
      - name: üß∞ Checkout du code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: üìñ Lire la version actuelle
        id: current_version
        run: |
          if [ -f version.txt ]; then
            CURRENT_VERSION=$(cat version.txt)
          else
            CURRENT_VERSION="v1.0.0"
            echo "$CURRENT_VERSION" > version.txt
          fi
          echo "version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          echo "üì¶ Version actuelle : $CURRENT_VERSION"

      - name: üîç Analyser les commits depuis la derni√®re version
        id: analyze_commits
        run: |
          # R√©cup√©rer tous les commits depuis le dernier tag
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          
          if [ -z "$LAST_TAG" ]; then
            # Premier commit
            COMMITS=$(git log --pretty=format:"%s" HEAD)
          else
            COMMITS=$(git log --pretty=format:"%s" ${LAST_TAG}..HEAD)
          fi
          
          echo "üìù Commits √† analyser :"
          echo "$COMMITS"
          
          # Analyser le type de changement (selon Conventional Commits)
          MAJOR=0
          MINOR=0
          PATCH=0
          
          while IFS= read -r commit; do
            # BREAKING CHANGE ou feat! = MAJOR
            if echo "$commit" | grep -qiE "^(feat|fix|chore|docs|style|refactor|perf|test)!:|BREAKING CHANGE"; then
              MAJOR=1
            # feat: = MINOR (nouvelle fonctionnalit√©)
            elif echo "$commit" | grep -qiE "^feat(\(.+\))?:"; then
              MINOR=1
            # fix:, chore:, etc. = PATCH
            elif echo "$commit" | grep -qiE "^(fix|chore|docs|style|refactor|perf|test)(\(.+\))?:"; then
              PATCH=1
            # Commit sans convention = PATCH par d√©faut
            else
              PATCH=1
            fi
          done <<< "$COMMITS"
          
          # D√©terminer le type de bump
          if [ $MAJOR -eq 1 ]; then
            BUMP_TYPE="major"
          elif [ $MINOR -eq 1 ]; then
            BUMP_TYPE="minor"
          else
            BUMP_TYPE="patch"
          fi
          
          echo "bump_type=$BUMP_TYPE" >> $GITHUB_OUTPUT
          echo "üéØ Type de changement d√©tect√© : $BUMP_TYPE"

      - name: ‚ûï Calculer la nouvelle version
        id: new_version
        run: |
          CURRENT="${{ steps.current_version.outputs.version }}"
          BUMP_TYPE="${{ steps.analyze_commits.outputs.bump_type }}"
          
          # Extraire les num√©ros (enlever le 'v')
          VERSION_NUM="${CURRENT#v}"
          
          # S√©parer MAJOR.MINOR.PATCH
          IFS='.' read -r MAJOR MINOR PATCH <<< "$VERSION_NUM"
          
          # Incr√©menter selon le type
          if [ "$BUMP_TYPE" = "major" ]; then
            MAJOR=$((MAJOR + 1))
            MINOR=0
            PATCH=0
          elif [ "$BUMP_TYPE" = "minor" ]; then
            MINOR=$((MINOR + 1))
            PATCH=0
          else
            PATCH=$((PATCH + 1))
          fi
          
          NEW_VERSION="v${MAJOR}.${MINOR}.${PATCH}"
          
          echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "major=$MAJOR" >> $GITHUB_OUTPUT
          echo "minor=$MINOR" >> $GITHUB_OUTPUT
          echo "patch=$PATCH" >> $GITHUB_OUTPUT
          
          echo "üéâ Nouvelle version : $NEW_VERSION"

      - name: üíæ Mettre √† jour version.txt
        run: |
          NEW_VERSION="${{ steps.new_version.outputs.version }}"
          echo "$NEW_VERSION" > version.txt
          echo "‚úÖ version.txt mis √† jour : $NEW_VERSION"

      - name: üîß Mettre √† jour auto_updater.py
        run: |
          NEW_VERSION="${{ steps.new_version.outputs.version }}"
          
          # Mettre √† jour VERSION_ACTUELLE dans auto_updater.py
          sed -i "s/VERSION_ACTUELLE = \"v[0-9]*\.[0-9]*\.[0-9]*\"/VERSION_ACTUELLE = \"$NEW_VERSION\"/" auto_updater.py
          
          echo "‚úÖ auto_updater.py mis √† jour : $NEW_VERSION"

      - name: üìù G√©n√©rer les notes de version automatiques
        id: release_notes
        run: |
          NEW_VERSION="${{ steps.new_version.outputs.version }}"
          BUMP_TYPE="${{ steps.analyze_commits.outputs.bump_type }}"
          
          # R√©cup√©rer les commits depuis le dernier tag
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          
          if [ -z "$LAST_TAG" ]; then
            COMMITS=$(git log --pretty=format:"%s" HEAD)
          else
            COMMITS=$(git log --pretty=format:"%s" ${LAST_TAG}..HEAD)
          fi
          
          # Cr√©er les sections
          FEATURES=""
          FIXES=""
          IMPROVEMENTS=""
          BREAKING=""
          OTHERS=""
          
          while IFS= read -r commit; do
            # BREAKING CHANGES
            if echo "$commit" | grep -qiE "BREAKING CHANGE|!:"; then
              BREAKING="${BREAKING}\n- ‚ö†Ô∏è ${commit}"
            # Nouvelles fonctionnalit√©s
            elif echo "$commit" | grep -qiE "^feat(\(.+\))?:"; then
              CLEAN_MSG=$(echo "$commit" | sed -E 's/^feat(\(.+\))?:\s*//')
              FEATURES="${FEATURES}\n- ‚ú® ${CLEAN_MSG}"
            # Corrections
            elif echo "$commit" | grep -qiE "^fix(\(.+\))?:"; then
              CLEAN_MSG=$(echo "$commit" | sed -E 's/^fix(\(.+\))?:\s*//')
              FIXES="${FIXES}\n- üêõ ${CLEAN_MSG}"
            # Am√©liorations de perf
            elif echo "$commit" | grep -qiE "^perf(\(.+\))?:"; then
              CLEAN_MSG=$(echo "$commit" | sed -E 's/^perf(\(.+\))?:\s*//')
              IMPROVEMENTS="${IMPROVEMENTS}\n- ‚ö° ${CLEAN_MSG}"
            # Refactoring
            elif echo "$commit" | grep -qiE "^refactor(\(.+\))?:"; then
              CLEAN_MSG=$(echo "$commit" | sed -E 's/^refactor(\(.+\))?:\s*//')
              IMPROVEMENTS="${IMPROVEMENTS}\n- üî® ${CLEAN_MSG}"
            # Autres
            else
              OTHERS="${OTHERS}\n- üìù ${commit}"
            fi
          done <<< "$COMMITS"
          
          # Construire les notes de version
          cat > release_notes.md << EOF
          ## üéâ Nouveaut√©s de $NEW_VERSION
          
          EOF
          
          if [ -n "$BREAKING" ]; then
            cat >> release_notes.md << EOF
          ### ‚ö†Ô∏è BREAKING CHANGES
          ${BREAKING}
          
          EOF
          fi
          
          if [ -n "$FEATURES" ]; then
            cat >> release_notes.md << EOF
          ### üéâ Nouvelles fonctionnalit√©s
          ${FEATURES}
          
          EOF
          fi
          
          if [ -n "$FIXES" ]; then
            cat >> release_notes.md << EOF
          ### üêõ Corrections de bugs
          ${FIXES}
          
          EOF
          fi
          
          if [ -n "$IMPROVEMENTS" ]; then
            cat >> release_notes.md << EOF
          ### ‚ö° Am√©liorations
          ${IMPROVEMENTS}
          
          EOF
          fi
          
          if [ -n "$OTHERS" ]; then
            cat >> release_notes.md << EOF
          ### üìù Autres changements
          ${OTHERS}
          
          EOF
          fi
          
          cat >> release_notes.md << EOF
          ---
          
          üìñ **Guide complet** : [GUIDE_INSTALLATION.md](https://github.com/${{ github.repository }}/blob/main/GUIDE_INSTALLATION.md)
          
          üîí **Note de s√©curit√©** : L'ex√©cutable Windows peut √™tre signal√© comme faux positif par certains antivirus (PyInstaller). C'est normal et document√© dans le guide.
          EOF
          
          echo "‚úÖ Notes de version g√©n√©r√©es"

      - name: üè∑Ô∏è Cr√©er un tag Git
        run: |
          NEW_VERSION="${{ steps.new_version.outputs.version }}"
          
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          
          git tag -a "$NEW_VERSION" -m "Release $NEW_VERSION"
          
          echo "‚úÖ Tag $NEW_VERSION cr√©√©"

      - name: üíæ Commit et push des changements
        run: |
          NEW_VERSION="${{ steps.new_version.outputs.version }}"
          BUMP_TYPE="${{ steps.analyze_commits.outputs.bump_type }}"
          
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          
          git add version.txt auto_updater.py
          git commit -m "chore: bump version to $NEW_VERSION [$BUMP_TYPE] [skip ci]"
          git push
          git push --tags
          
          echo "‚úÖ Version $NEW_VERSION committ√©e et push√©e avec le tag"

      - name: üöÄ D√©clencher le workflow de build
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'build.yml',
              ref: '${{ steps.new_version.outputs.version }}'
            });
            console.log('‚úÖ Workflow de build d√©clench√© pour ${{ steps.new_version.outputs.version }}');

      - name: üì¶ Cr√©er la draft release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.new_version.outputs.version }}
          name: "Gestion Financi√®re Little ${{ steps.new_version.outputs.version }}"
          body_path: release_notes.md
          draft: true
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: üéâ Notification de succ√®s
        if: success()
        run: |
          echo "=================================="
          echo "‚úÖ VERSION INCR√âMENT√âE !"
          echo "=================================="
          echo ""
          echo "üì¶ Nouvelle version : ${{ steps.new_version.outputs.version }}"
          echo "üìà Type de bump : ${{ steps.analyze_commits.outputs.bump_type }}"
          echo "üè∑Ô∏è Tag cr√©√© : ${{ steps.new_version.outputs.version }}"
          echo ""
          echo "üìù Prochaines √©tapes :"
          echo "   1. Le workflow de build va se lancer automatiquement"
          echo "   2. Une draft release sera cr√©√©e sur GitHub"
          echo "   3. Teste la release et publie-la quand tu es pr√™t"
          echo ""
          echo "=================================="
