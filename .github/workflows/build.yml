name: 🚀 Build & Release Gestion Financière Little

permissions:
  contents: write
  actions: read

on:
  push:
    branches: [ main ]
  workflow_dispatch:

jobs:
  build:
    name: Build et Release multi-plateforme
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [windows-latest, ubuntu-latest, macos-latest]

    steps:
      - name: 🧰 Checkout du code
        uses: actions/checkout@v4

      - name: 🐍 Installer Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: 📦 Installer les dépendances
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pyinstaller

      - name: 🏗️ Compiler l'application (optimisé antivirus)
        run: |
          # Lister tous les fichiers Python du projet
          python_files=$(find . -name "*.py" -not -path "./.git/*" -not -path "./build/*" -not -path "./dist/*" | tr '\n' ':')
          
          # Créer un fichier .spec optimisé pour réduire les faux positifs
          cat > gestiolittle.spec << 'EOF'
          # -*- mode: python ; coding: utf-8 -*-
          import os
          import glob
          
          block_cipher = None
          
          # Collecter tous les fichiers .py du projet
          py_files = glob.glob('*.py')
          datas_list = [(f, '.') for f in py_files if f != 'lancer_gestiolittle.py']
          
          a = Analysis(
              ['lancer_gestiolittle.py'],
              pathex=[],
              binaries=[],
              datas=datas_list,
              hiddenimports=[],
              hookspath=[],
              hooksconfig={},
              runtime_hooks=[],
              excludes=['pytest', 'unittest', 'test', '_pytest', 'setuptools', 'pip', 'wheel'],
              win_no_prefer_redirects=False,
              win_private_assemblies=False,
              cipher=block_cipher,
              noarchive=False,
          )
          
          pyz = PYZ(a.pure, a.zipped_data, cipher=block_cipher)
          
          exe = EXE(
              pyz,
              a.scripts,
              a.binaries,
              a.zipfiles,
              a.datas,
              [],
              name='GestionFinanciereLittle',
              debug=False,
              bootloader_ignore_signals=False,
              strip=False,
              upx=False,
              console=True,
              disable_windowed_traceback=False,
              argv_emulation=False,
              target_arch=None,
              codesign_identity=None,
              entitlements_file=None,
          )
          EOF
          
          # Compiler avec le .spec optimisé
          pyinstaller gestiolittle.spec --clean --noconfirm
        shell: bash

      # 🧩 Installation du SDK Windows pour avoir signtool
      - name: 🧩 Installer Windows SDK pour obtenir signtool
        if: runner.os == 'Windows'
        run: choco install windows-sdk-10-version-2004-all -y

      # 🪪 Import du certificat de signature
      - name: 🪪 Importer le certificat PFX dans le store Windows
        if: runner.os == 'Windows'
        shell: powershell
        run: |
          # Décoder et sauvegarder le certificat
          $bytes = [System.Convert]::FromBase64String("${{ secrets.CODESIGN_PFX_BASE64 }}")
          $pfxPath = "codesign.pfx"
          [IO.File]::WriteAllBytes($pfxPath, $bytes)
          
          # Vérifier si le mot de passe existe
          $passwordString = "${{ secrets.CODESIGN_PFX_PASSWORD }}"
          
          if ([string]::IsNullOrEmpty($passwordString)) {
            Write-Host "⚠️ Mot de passe vide, tentative d'import sans mot de passe..."
            try {
              Import-PfxCertificate -FilePath $pfxPath -CertStoreLocation Cert:\CurrentUser\My -Exportable
              Write-Host "✅ Certificat importé sans mot de passe"
            } catch {
              Write-Error "❌ Impossible d'importer le certificat sans mot de passe : $_"
              Write-Host "💡 Si votre certificat a un mot de passe, ajoutez le secret CODESIGN_PFX_PASSWORD dans GitHub"
              exit 1
            }
          } else {
            Write-Host "🔐 Import du certificat avec mot de passe..."
            $password = ConvertTo-SecureString -String $passwordString -Force -AsPlainText
            try {
              Import-PfxCertificate -FilePath $pfxPath -CertStoreLocation Cert:\CurrentUser\My -Password $password -Exportable
              Write-Host "✅ Certificat importé avec mot de passe"
            } catch {
              Write-Error "❌ Erreur lors de l'import du certificat : $_"
              exit 1
            }
          }
          
          Write-Host "✅ Certificat importé dans le store Windows"

      # 🔏 Signature de l'exécutable Windows
      - name: 🔏 Signer l'exécutable Windows
        if: runner.os == 'Windows'
        shell: powershell
        run: |
          # Récupérer le thumbprint du certificat
          $cert = Get-ChildItem Cert:\CurrentUser\My | Where-Object { $_.Subject -match "CN=" } | Select-Object -First 1
          
          if (-not $cert) {
            Write-Error "❌ Aucun certificat trouvé dans le store"
            exit 1
          }
          
          Write-Host "✅ Certificat trouvé : $($cert.Subject)"
          Write-Host "   Thumbprint: $($cert.Thumbprint)"

          # Chercher signtool.exe
          $signtool = Get-ChildItem "C:\Program Files (x86)\Windows Kits\10\bin\" -Recurse -Filter signtool.exe |
            Where-Object { $_.FullName -match "\\x64\\" } |
            Select-Object -First 1 -ExpandProperty FullName

          if (-not $signtool) {
            Write-Host "⚠️ signtool.exe (x64) non trouvé, tentative de fallback..."
            $signtool = Get-ChildItem "C:\Program Files (x86)\Windows Kits\10\bin\" -Recurse -Filter signtool.exe |
              Select-Object -First 1 -ExpandProperty FullName
          }

          if (-not $signtool) {
            Write-Error "❌ signtool.exe non trouvé"
            exit 1
          }

          Write-Host "✅ signtool utilisé : $signtool"

          # Signature avec le certificat du store (via thumbprint)
          & "$signtool" sign /sha1 $cert.Thumbprint `
            /tr http://timestamp.digicert.com /td sha256 /fd sha256 `
            "dist\lancer_gestiolittle.exe"

          if ($LASTEXITCODE -ne 0) {
            Write-Error "❌ Erreur lors de la signature"
            exit $LASTEXITCODE
          }

          Write-Host "✅ Signature terminée avec succès"

      # 📤 Création de la release GitHub
      - name: 📤 Upload de l'exécutable pour la Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ github.run_number }}
          name: "Gestion Financière Little v${{ github.run_number }}"
          body: |
            🚀 Nouvelle version générée automatiquement.

            ✅ Compatible Windows, Linux et macOS.
            🔏 L'exécutable Windows est signé numériquement.
          files: |
            dist/GestionFinanciereLittle*
          fail_on_unmatched_files: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
