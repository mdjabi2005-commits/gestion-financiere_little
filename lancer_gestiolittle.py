import os
import sys
import subprocess
import webbrowser
import time
import socket
import shutil
import tempfile
import json
from pathlib import Path

def ouvrir_guide_installation():
    """Ouvre le guide d'installation si c'est le premier lancement"""
    
    # Chemin du fichier de configuration
    config_dir = Path.home() / ".gestiolittle"
    config_file = config_dir / "üß™ Guide d'Installation pour Testeurs Beta"
    
    # Cr√©er le dossier de configuration s'il n'existe pas
    config_dir.mkdir(exist_ok=True)
    
    # Charger ou initialiser la configuration
    if config_file.exists():
        with open(config_file, 'r', encoding='utf-8') as f:
            config = json.load(f)
    else:
        config = {"premier_lancement": True, "lancements": 0}
    
    # Incr√©menter le compteur de lancements
    config["lancements"] = config.get("lancements", 0) + 1
    
    # V√©rifier si c'est le premier lancement ou tous les 10 lancements
    premier_lancement = config.get("premier_lancement", True)
    lancements = config.get("lancements", 0)
    
    # Chemin du guide d'installation
    guide_path = Path(__file__).parent / "GUIDE_INSTALLATION.md"
    
    # Ouvrir le guide dans les cas suivants :
    ouvrir_guide = False
    
    if premier_lancement:
        print("üéâ Premier lancement - Ouverture du guide d'installation...")
        ouvrir_guide = True
        config["premier_lancement"] = False
    
    elif lancements % 10 == 0:  # Tous les 10 lancements
        print("üìñ Rappel - Ouverture du guide d'installation...")
        ouvrir_guide = True
    
    # Sauvegarder la configuration
    with open(config_file, 'w', encoding='utf-8') as f:
        json.dump(config, f, indent=2)
    
    # Ouvrir le guide si n√©cessaire
    if ouvrir_guide and guide_path.exists():
        try:
            if sys.platform == "win32":
                # Windows
                os.startfile(str(guide_path))
            elif sys.platform == "darwin":
                # macOS
                subprocess.run(["open", str(guide_path)])
            else:
                # Linux
                subprocess.run(["xdg-open", str(guide_path)])
            print("üìö Guide d'installation ouvert !")
            # Attendre un peu que le guide s'ouvre
            time.sleep(2)
        except Exception as e:
            print(f"‚ùå Impossible d'ouvrir le guide: {e}")

def wait_for_port(port, timeout=20):
    """Attend que le port Streamlit soit ouvert (jusqu'√† timeout secondes)."""
    start = time.time()
    while time.time() - start < timeout:
        try:
            with socket.create_connection(("localhost", port), timeout=1):
                return True
        except OSError:
            time.sleep(0.5)
    return False

def get_base_path():
    """Retourne le chemin de base, m√™me si le programme est compil√© avec PyInstaller."""
    if getattr(sys, 'frozen', False):
        # Si compil√© avec PyInstaller, utilise le dossier temporaire d'extraction
        return sys._MEIPASS
    return os.path.dirname(os.path.abspath(__file__))

def find_app_path(base_path):
    """Cherche le fichier gestiolittle.py √† partir de l'emplacement courant."""
    candidates = [
        os.path.join(base_path, "gestiolittle.py"),
        os.path.join(os.path.dirname(base_path), "gestiolittle.py"),
        os.path.join(os.getcwd(), "gestiolittle.py")
    ]

    for path in candidates:
        if os.path.exists(path):
            return path

    print("‚ùå Impossible de trouver gestiolittle.py")
    print("Chemins test√©s :")
    for p in candidates:
        print(f"   - {p}")
    print("\nüí° Le fichier gestiolittle.py doit √™tre dans le m√™me dossier que l'ex√©cutable.")
    input("\nAppuie sur Entr√©e pour fermer‚Ä¶")
    sys.exit(1)

def launch_streamlit(app_path, port=8501):
    """Lance Streamlit proprement et ouvre le navigateur quand le serveur est pr√™t."""
    streamlit_exe = shutil.which("streamlit")

    if not streamlit_exe:
        print("‚ùå Streamlit introuvable ! V√©rifie que Streamlit est bien install√©.")
        print("Essaie : pip install streamlit")
        input("Appuie sur Entr√©e pour fermer‚Ä¶")
        sys.exit(1)

    # Commande adapt√©e selon l'OS
    if sys.platform == "win32":
        cmd = [
            "powershell", "-Command",
            f'& "{streamlit_exe}" run "{app_path}" --server.port {port}'
        ]
    else:
        cmd = [streamlit_exe, "run", app_path, "--server.port", str(port)]

    print(f"Lancement de Streamlit √† partir de : {streamlit_exe}")
    print(f"Application : {app_path}")

    # Lance Streamlit en t√¢che de fond
    process = subprocess.Popen(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)

    # Attendre que le serveur d√©marre
    if wait_for_port(port, timeout=30):
        print("‚úÖ Serveur pr√™t ! Ouverture du navigateur‚Ä¶")
        webbrowser.open(f"http://localhost:{port}")
    else:
        print("‚ö†Ô∏è Le serveur Streamlit ne s'est pas lanc√© correctement.")
        print("Essaye de lancer depuis le terminal pour voir les logs :")
        print(f"   streamlit run \"{app_path}\" --server.port {port}")
        input("\nAppuie sur Entr√©e pour fermer‚Ä¶")
        sys.exit(1)

    return process

def main():
    print("üöÄ D√©marrage de Gestion Financi√®re Little‚Ä¶")

    # 1. Ouvrir le guide d'installation si n√©cessaire
    ouvrir_guide_installation()

    # 2. Lancer l'application Streamlit normale
    base_path = get_base_path()
    app_path = find_app_path(base_path)
    launch_streamlit(app_path)

    print("‚úÖ Application lanc√©e avec succ√®s.")
    print("üí° Ferme cette fen√™tre pour arr√™ter l'application.")
    
    # Garde la fen√™tre ouverte
    try:
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        print("\nüõë Arr√™t de l'application...")
        sys.exit(0)

if __name__ == "__main__":
    main()